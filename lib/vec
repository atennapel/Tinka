import lib/sum;
import lib/nat;
import lib/eq;
import lib/idata;

let -VecF : * -> (Nat -> *) -> Nat -> * = \A R n. Sum (Eq 0 n) ((-m : Nat) ** A ** R m ** (Eq (S m) n));
let -Vec : Nat -> * -> * = \n A. IData (VecF A) n;
let VNil : {-A : *} -> Vec 0 A = \{A}. ICon {_} {VecF A} (Left Refl);
let VCons : {-A : *} -> {-n : Nat} -> A -> Vec n A -> Vec (S n) A
  = \{A} {n} hd tl. ICon {_} {VecF A} (Right (n, hd, tl, Refl));

let elimVec
  : {-A : *} ->
    (-P : {n : Nat} -> Vec n A -> *) ->
    P VNil ->
    (({-n : Nat} -> (v : Vec n A) -> P v) -> {-m : Nat} -> (hd : A) -> (tl : Vec m A) -> P (VCons hd tl)) ->
    {-n : Nat} ->
    (v : Vec n A) ->
    P v
  = \{A} P nil cons {n} v. elimIData {_} {VecF A} P (\rec {m} y. elimSum (\s. P (ICon {_} {VecF A} {m} s))
      (\q. elimEq (\e. P (ICon {_} {VecF A} (Left e))) nil q)
      (\p.
        let -mm = p.0;
        let hd = p.1;
        let tl = p.2;
        let q = p._2._2._2;
        elimEq (\{j} e. P {j} (ICon {_} {VecF A} (Right (mm, hd, tl, e)))) (cons @rec {mm} hd tl) q)
    y) {n} v;

let foldrVec : {-A -R : *} -> {-n : Nat} -> R -> (A -> R -> R) -> Vec n A -> R
  = \{A} {R} {n} nil cons v. elimVec (\_. R) nil (\rec hd tl. cons hd (rec tl)) v;

let mapVec : {-A -B : *} -> {-n : Nat} -> (A -> B) -> Vec n A -> Vec n B
  = \{A} {B} fn v. elimVec (\{n} _. Vec n B) VNil (\rec hd tl. VCons (fn hd) (rec tl)) v;

[VecF, Vec, @VNil, @VCons, @elimVec, @foldrVec, @mapVec]
:
(-VecF : * -> (Nat -> *) -> Nat -> *)
**
(-Vec : Nat -> * -> *)
**
(VNil : {-A : *} -> Vec 0 A)
**
(VCons : {-A : *} -> {-n : Nat} -> A -> Vec n A -> Vec (S n) A)
**
(elimVec
  : {-A : *} ->
    (-P : {n : Nat} -> Vec n A -> *) ->
    P VNil ->
    (({-n : Nat} -> (v : Vec n A) -> P v) -> {-m : Nat} -> (hd : A) -> (tl : Vec m A) -> P (VCons hd tl)) ->
    {-n : Nat} ->
    (v : Vec n A) ->
    P v)
**
(foldrVec : {-A -R : *} -> {-n : Nat} -> R -> (A -> R -> R) -> Vec n A -> R)
**
(mapVec : {-A -B : *} -> {-n : Nat} -> (A -> B) -> Vec n A -> Vec n B)
**
()
